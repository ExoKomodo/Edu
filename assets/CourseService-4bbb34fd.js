var y=Object.defineProperty;var w=(s,e,t)=>e in s?y(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var l=(s,e,t)=>(w(s,typeof e!="symbol"?e+"":e,t),t);import{H as o,s as i,x as d}from"./index-bb143292.js";import{S as A}from"./SectionService-c2dfd566.js";import{A as h}from"./AssignmentService-e59bc306.js";import{B as g}from"./BlogService-4efc6870.js";class f{static async getPresignedUrlAsync(e,t={}){var r;try{return await o.getTextAsync(`blob?url=${e}`,t)}catch(c){throw(r=t.toast)==null||r.error(`Failed to get blob's presigned url: ${c}`),c}}}class m{static inject(e){switch(e){case"assignment":return new h;case"blog":return new g;case"course":return new k;case"section":return new A;default:throw new Error(`Unknown kind: ${e}`)}}static async fillTemplateAsync(e,t={}){if(!e)return"";const r=/"\${([0-9a-zA-Z_\-\/\.]+)}"/g,c=new Map;for(let a of e.matchAll(r)){const n=a[0],u=a[1];n in c||c.set(n,await f.getPresignedUrlAsync(u,t))}for(let[a,n]of c)e=e.replace(a,n);return e}}class k{constructor(){l(this,"objectViewKeys",[{key:"id",kind:"text"},{key:"name",kind:"code"},{key:"description",kind:"code"},{key:"content",kind:"code"}])}make(){return new i({})}static async createAsync(e,t={}){var r;try{return new i(await o.postAsync("course",e,t))}catch(c){throw(r=t.toast)==null||r.error(`Failed to create course: ${c}`),c}}static async deleteAsync(e,t={}){var r;try{return new i(await o.deleteAsync("course",e,t))}catch(c){throw(r=t.toast)==null||r.error(`Failed to delete course: ${c}`),c}}static async getAsync(e,t={}){var r,c;try{const a=new i(await o.getAsync("course",e,t));try{a.templatedContent=await m.fillTemplateAsync(a.content,t)}catch(n){throw(r=t.toast)==null||r.error(`Failed to fill template for course content: ${n}`),n}return a}catch(a){throw(c=t.toast)==null||c.error(`Failed to get course: ${a}`),a}}static async getAllAsync(e={}){var t;try{const r=await o.getAllAsync("course",e);return Object.keys(r).forEach(function(c,a){r[c]=new d(r[c])}),new Map(Object.entries(r))}catch(r){throw(t=e.toast)==null||t.error(`Failed to get all courses: ${r}`),r}}static async updateAsync(e,t={}){var r;try{return new i(await o.putAsync("course",e,t))}catch(c){throw(r=t.toast)==null||r.error(`Failed to update course: ${c}`),c}}}export{k as C,m as M};
